gestion de memoire optimisee (et facilite pour free) : 

Objectifs : 
	un pointeur sur une zone memoire capable de stocker plusieurs instances d'un
	type de donnees, a ne malloc qu'une fois.
	gestion de la memoire liberee (chaque fois qu'une instance n'est plus utile)
	si la zone memoire est pleine, reallocation sur une taille doublee

pour chaque type de donnees de base (hors tableau) qui va etre malloc : 

on alloue un tableau de taille arbitraire pour le type de donnee, qu'on stocke
dans une variable "globale" qui sera transferee partout.
	-> utiliser le type Array deja cree ou insuffisant ? 
		-> pouvoir definir le sizeof des items
		-> le stocker dans l'array (pour toutes les fonctions de skip)
		-< probleme pour ajouter les donnees ?
			-/> solution1 : passer un pointeur sur une donnee non malloc pre-remplie (2x plus long)
			-> solution2 : faire une requete d'un emplacement disponible et remplir apres coup 
				-> toujours tout remplir (meme de NULL) car la "liberation" de l'item ne fera pas d'overwrite
			

gestion de disponibilite : 

liste chainee d'index disponibles dans la zone (unused) (LIFO)
liste chainee d'index utilises (used)
	-> comment indiquer que certains index sont liberes avec une gestion minimale "in place"
		-> solution1 : fonction "same level", "lower level" pour peupler une liste LIFO de listes chainees
			a chaque fin de portee, indiquer qu'on libere le dernier niveau ajoute
			-< probleme si on veut faire persister certaines donnees a un niveau plus haut?
		-> solution2 : tableau de liste chainees d'index utilises dans un meme contexte
			-> le contexte doit retenir l'index assigne et indiquer quand il le libere
				-> creer une structure "manager de contexte" qui contient un pointeur 
					type generique "gestion des index memoire" + l'index en question


-> modifier le array actuel pour ne plus faire un array de pointeurs

-> utiliser memcpy (ou alternative) pour ecrire la donnee de type inconnu (on connait le sizeof)



recovery ->

adapter memarrah.h pour retirer les index
-> adapter memarray.c pour retirer les index
-> voir si un type de fonction manque a memarray.c
-> appliquer les tests de array.c
-> creer les tests de memarray.c



-> creer une structure /liste chainee\ qui stocke tous les usages
d'un bloc de code, qui pourra etre ensuite refusionnee avec unused ?
->> simplement faire la liste chainee pendant l'usage





Gestion d'erreur memoire dans le programme + organisation de l'allocation
memoire

Principes : 

-> Toute la gestion memoire se fait avec des memarray.
-> A chaque retour d'erreur d'une fonction memarray, il faut interrompre le
	programme et liberer toute la memoire.
-> Une entite de gestion initialisee au debut du programme doit controler tous
	les memarray
-> Chaque "transition" du programme doit verifier la coherence de l'entite de
	gestion avant application de son contenu
-> Une erreur de fonction memarray doit donc interrompre une "transition"
	afin que la prochaine verification declenche la procedure d'arret
-> Une "transition" est definie comme l'intermediaire entre un calcul
	produisant un resultat a stocker en memoire et une fonction utilisant ce
	resultat



-> test de memarray

-> requete de memoire
	-> tester used & unused
	-> tester plusieurs requetes de memoire independantes
	-> tester jusqu'au realloc
-> refill
	-> tester plusieurs refill partiels
	-> tester used & unused (somme toujours coherente)
	-> tester une alternance de refill et de requetes memoires partiels avec
		un realloc pendant l'operation
-> free
	-> tester un free avant usage
	-> tester un free pendant usage
	-> tester un free apres usage



-> probleme majeur du concept : 
	-> en cas de realloc, tous les utilisateurs des addresses precedemment
		accordees ne possedent plus le bon lien, meme si l'information
		est recopiee
		-> solution : imaginer un syteme incremental en liste chainee
			-> probleme : addresses dans 2 blocs differents pour un usage
				dans une seule situation
				-> liste chainee symetrique de memused ?


-> resolution du probleme de realloc
	-> travailler avec un array de memarray (recopier les addresse en cas de
		realloc ne posera pas de probleme, puisqu'on ne free pas les addresses
		liees a la data)
	-> (maintenir une liste triee des index du tableau en fonction des 
		disponibilites sur l'index)
	-> necessite d'un tableau de memused (pour chaque index)
	
	-> memarray de memused + possibilite de liste chainee + stockage index

	OU -> chaque memitem sait a quel index il appartient
		-> MAIS necessite de reparcourir tous les memitems lors du refill
		-> perte de performance
		OU -> liste chainee secondaire des "oldest" au lieu d'un seul
			-> oldest devient un type a part de memitem, qui pointe sur 3 memitems
				1 - le memitem oldest du meme index (same as before)
				2 - le oldestitem de l'index suivant (liste chainee oldest)
				3 - le memitem newest de l'index suivant (lien dans memitem)


management de disponibilite:
	-> compte de dispo sur le memarray
	-> compte d'usage sur les memitems (lie a newest)
	-> index du dernier utilise sur memanager
		-> evolution a l'index minimum lors du refill
	



refill : 
	- memitem -> oldest a remettre dans unused
	- n_unused a mettre a jour avec n_used de memitem
	- avancer newest si non null, avancer oldest

get : 
	- partir du dernier index "available" et avancer jusqu'a
		trouver un dispo, si pas, rajouter un tableau d'addresses
	- tester si meme i_memarray que precedent
		- oui : recup l'addresse, incrementer n_used
		- non : 
			- memitem va sur newest
			- le nouvel item devient un nouvel oldest
			- nouvel item devient memitem, n_used = 1



-> integrer le reader et le memory manager a la libft
-> retirer le get_next_line de la libft
-> retravailler l'organisation de la libft


refaire le makefile de libft normale
integrer le reader
integrer le memory manager


-> separer array de memarray
-> ajouter btree a la libft
-> ? faire une hashmap
-> restructurer la reflexion pour toute la libft

---------------------------
/////IMPORTANT\\\\\

pour tout objet, creer un "constructeur" faisant usage du
memory_manager -> plus de malloc

-> pour les tableaux -> retirer le malloc de la structure, mais laisser
	le malloc des items => il faudra les free 

---------------------------

MEMUSED -> fonctions d'alteration
-> pour rendre une seule addresse ?
-> ajout d'une liste chainee a usage local
-> permet de liberer et reutiliser des addresses
	sans les rendre au memanager
-> reste "consommee" jusqu'a la fin du process qui
	utilise l'addresse, mais celui-ci ne fera
	pas de requete a memanager tant qu'il peut se servir
	dans cette liste-ci

==> probleme : a reflechir
-> chaque bnode possede son memitem
	-> ajouter a memused un pointeur vers liste chainee
	-> les fonctions de get vont d'abord vider cette liste
	-> initaliseur de memused pour future evolution

-> ne pas rendre les addresses supprimees et compter les
	"fuites", ainsi que les elements du btree. Une fois une
	certaine proportion atteinte d'addresses "perdues",
	recopier le btree dans un nouveau et rendre l'ancien

-> ne pas detruire les bnodes dont on retire les donnees,
	-> les reutiliser des que besoin sans avoir besoin de les
	reconstruire -> marche pas!


-> reutiliser le concept de filler pour le memory manager
	-> permettra de gerer les tableaux et structures a 
	taille variable
	-> penser a retirer les fonctions de recovery
		-> on pourra rendre toute addresse n'importe quand
			avec le nouveau systeme

---------------------------


reflexion wavl

////IMPORTANT\\\\
-> utiliser le memory_manager pour la gestion des nouveaux noeuds du btree
	- fournir un memory manager externe pour la gestion
		-> permet d'utiliser les fonctions de requete sans se preoccuper de la
			taille derriere le memory manager
		-> integrer un facteur d'augmentation de memoire
	- envelopper le t_btree dans un conteneur ???

root : up == NULL
leaves : rank == 1
parent of non-root rank = r : rank = r + (1 || 2)

-> search : 
	- standard binary search

-> insertion :
	- search position where the new item should be
	- new item -> rank = 1
	- go up the tree and increment each parent if necessary until :
		- root was incremented
		- rank_parent > rank_last_incremented
		- rank_last_incremented = rank_parent > rank_other_child + 1
			- rotate the tree (1 or 2 times) : method -> keep the weak side at the same level
				- 1 rotation : weak side is centered -> rotate around it
				- 2 rotations : weak side is to the side
					- use the centered node of the strong side as the center of the 1st rotation
					- then the sided node of the strong side as the center of the 2nd rotation

-> deletion :
	- search position of the item
	- if the item has at least 1 external child, 
		deletion of this node and the external child (recovery)
		the other child takes its place
	- if the item has no internal child



-----------------------------------

reflexion probleme btree remove

-> probleme -> rank pas bien mis a jour
	en cas de deletion
	-> voir log
		-> symptomes : une difference de rank de 3 persiste
			apres un rebalancing


------------------------------------

-> tester btree remove
	-> retrouver comment utiliser le makefile windows

-> implementer memory manager

-> tester printf avec des pointeurs et des floats sur windows
		-> semble ne pas fonctionner sur windows
-> tester array avec les modifs char


-> bug de reranking hypothese : 
	-> lors de la double rotation, on part trop bas dans
		l'arbre pour le rebalancing, ca trigger pas
		-> on saute la diff de 3 juste au dessus

------------------------------------

nouveau memory manager : 

OK -> faire en sorte que le btree soit utilisable avec une fonction
	de comparaison externe et un type de comparaison externe

-> comment stocker la memoire disponible et y acceder rapidement
	-> arbre binaire de tailles disponibles aboutissant a une liste chainee
		d'elements pointant vers une meme taille
		-> stockage de l'arbre binaire dans un memory manager vieille version
		-> probleme : acces memoire de temps logarithmique vis a vis des differentes tailles
			-> on match des qu'on trouve une memoire plus grande que ce dont on a besoin
				-> pire des cas = logarithmique, meilleur = quasi instantane
		-> probleme : operations de modifications de l'arbre sont de complexite logarithmique
		-> probleme : si la recherche passe par les "petits" et qu'on ne trouve pas de resultat
			-> pas un probleme, si ce cas arrive, il faut un nouveau bloc memoire
	-> cache memoire ?

-> un arbre binaire a comparaison de tailles pour avoir un acces memoire
	chaque noeud doit etre un arbre binaire a comparaison d'addresse
	-> donner le premier acces memoire qui match peu importe la fragmentation
	-> donner une addresse (4 log t + 2 log a) :
		- retirer de l'arbre la taille voulue (2 log t)
			- retirer root
		- ajouter le jumper en memoire
			- si pas la place, on conserve le jumper precedent (mini fragmentation)
			- adapter le jumper precedent et le jumper suivant
		- ajouter a l'arbre la taille restante (2 log t + 2 log a)
		- si pas la taille voulue, refaire un bloc (avec au minimum la taille voulue)
	-> rendre une addresse (6 log t + 6 log a)
		- trouver les addresses voisines (4 log t + 4 log a)
			- si present :
				- retirer de l'arbre binaire (pas refaire la recherche)
				- fusion des jumpers (si 2 presents, faire une double fusion)
				- ajouter la nouvelle taille a l'arbre (2 log t + 2 log a)
			- sinon : 
				- ajouter a l'arbre la taille courante (2 log t + 2 log a)

		 


-> rendre la memoire : retrouver rapidement le bloc d'appartenance
	(en cas de multiples blocs)
	-> arbre binaire special avec fonction de comparaison speciale ?
-> reflexion sur rendre plusieurs pointeurs a la fois de maniere efficace
	+ fonctions de array qui travaillent avec memarray et pas avec malloc, 
	tout en gardant l'extension possible de la meme facon
-> adapter btree au nouveau memory manager
-> utiliser le premier type de memory manager en support du 2eme ?



-> reflexion courante : regarder dans btree ce qui doit etre change
	pour que named devienne void
	-> a priori ca fonctionne, mettre named en void, ajuster partout
		-> mettre la fonction de comparaison en argument de fonction
		-> l'externe doit jauger lui meme de la faisabilite de ses choix
		-> permet la generalisation du btree

-> adapter le btree
	-> repasser la sequence de test
-> faire les fonctions de comparaison intervalle d'addresses et
	addresses

	-> choisir le type de conversion pour comparer les pointeurs -> uintmax_t ou uintptr_t

-> tester un btree trie par taille (size_t)
-> tester un btree trie par addresse

-> segfault construction de tableau copie de btree size_t